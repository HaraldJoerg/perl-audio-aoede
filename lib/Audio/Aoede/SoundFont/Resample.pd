# template auto generated by pptemplate
# uncomment commands, copy and fill in as needed
# see also the PDL::PP manpage

use strict;
use warnings;

our $VERSION = '0.01';
pp_setversion($VERSION);

{ no warnings 'once'; # pass info back to Makefile.PL
#$PDL::Core::Dev::EXTRAS{$::PDLMOD}{OBJECT} .= join '', map " $::PDLBASE/$_\1000 4 24 27 30 46 122 135 136 137 1000OBJ_EXT)", qw(fftn);
#$PDL::Core::Dev::EXTRAS{$::PDLMOD}{DEFINE} .= qq{ -DFFT_FLOAT -DFFT_DOUBLE -DFFT_LDOUBLE};
#$PDL::Core::Dev::EXTRAS{$::PDLMOD}{INC} .= qq{ "-I$::PDLBASE"};
}

# pp_bless('');       # package namespace of pp_def'ed functions
		      # defaults to 'PDL'

# pp_add_boot('');    # code to add to the XS boot section

# pp_addhdr('');      # add C code to the section preceding
		      # the first MODULE keyword

pp_addpm({At=>'Top'}, <<'EOPM');
use strict;
use warnings;

=head1 NAME

Audio::Aoede::SoundFont::Resample - Resample a SoundFont sample

=head1 SYNOPSIS

  use Audio::Aoede::SoundFont::Resample;
  # This is for internal use by Audio::Aoede::SoundFont.

=head1 DESCRIPTION

This module converts a sound sample from a SoundFont file to a new
pitch, which can change over time as given by the SoundFont generator
C<modEnvToPitch>.

Doing this in Perl is too slow, and L<PDL> has no built-in for this
very specific need.  Therefore (and because I wanted to learn that
anyway) I implemented it as a L<PDL::PP> module.

The module has not been extensively tested, but it seems to work for
SoundFont presets where C<modEnvToPitch> is used to achieve a vibrato
effect.

=head1 AUTHOR

Harald Jörg, E<lt>haj@posteo.deE<gt>.  I used ChatGPT to get me
started.

=head1 COPYRIGHT AND LICENSE

Copyright 2025 Harald Jörg

This module is part of the L<Audio::Aoede> suite. It is free software;
you may redistribute it and/or modify it under the same terms as Perl
itself.


=cut

EOPM

# pp_add_exported(''); # add the list of functions
                       # to the list of exported functions

# pp_addxs('');        # add plain XS code to the XS section

# pp_add_isa(qw//);    # inheritance business: add arglist to modules @ISA

pp_def('resample_with_loop',
    Pars => 'sample_data(n); playback_rates(m); [o]output(m); state(nstate);',
    OtherPars => 'int start_loop; int end_loop;',
    GenericTypes => ['F', 'D'],  # Support both float and double
    Code => q{
        $GENERIC(sample_data) *data = $P(sample_data);
        int sample_len = $SIZE(n);
        int loop_len = $COMP(end_loop) - $COMP(start_loop);

        $GENERIC(state) read_pos = $state(nstate => 0);

        loop(m) %{
            $GENERIC(playback_rates) rate = $playback_rates();
            read_pos += rate;

            if (read_pos >= $COMP(end_loop)) {
                read_pos = $COMP(start_loop) + fmod(read_pos - $COMP(start_loop), loop_len);
            }

            if (read_pos >= sample_len - 1) {
                $output() = 0;
                continue;
            }

            int index = (int)read_pos;
            $GENERIC() frac = read_pos - index;

            $GENERIC(sample_data) samp0 = data[index];
            $GENERIC(sample_data) samp1 = data[(index + 1) % sample_len];

            $output() = (1 - frac) * samp0 + frac * samp1;
        %}

        $state(nstate => 0) = read_pos;
    }
);

pp_done();  # you will need this to finish pp processing

1;
