# ABSTRACT: Real-time sound
use 5.032;
use Feature::Compat::Class;
use feature "signatures";
no warnings "experimental";

class Audio::Aoede::Server {
    field $rate     :param = 44100; # Because that's what my card does
    field $encoding :param = 'signed-integer'; # Not yet usable by SoX
    field $bits     :param = 16;
    field $channels :param = 1;

    field $player;
    field $amplitude = 2**15-1;

    field @voices;
    field $start_time;
    field $current_sample; # samples before this one have been processed
    field $silent = 1;

    use PDL;
    use Time::HiRes qw(tv_interval gettimeofday usleep);
    use constant DEBUG => '';

    use Audio::Aoede::Player::SoX;

    ADJUST {
        @voices = ();
        $start_time = [gettimeofday];
        $current_sample = 0;
    }

    # Returns a float piddle of $n_samples samples
    method fetch_data($n_samples,$since = $current_sample) {
        my $sound = zeroes($n_samples);
        my $volume = 0;
        for my $voice (@voices) {
            $sound  += $voice->volume *
                $voice->next_samples($n_samples,$since);
            $volume += $voice->volume;
        }
        if ($volume < 0.01) {
            my $silence = zeroes($n_samples);
            return $silence;
        }
        else {
            if ($volume > 1.0) {
                $sound /= $volume;
            }
            return $sound;
        }
    }

    method add_voices(@new_voices) {
        push @voices,@new_voices;
    }

    method remove_voice($old_voice) {
        @voices = grep { $_ != $old_voice } @voices;
    }

    method start () {
	$player = Audio::Aoede::Player::SoX->new(
	    rate	=> $rate,
	    # encoding	=> $encoding,
	    bits	=> $bits,
	    channels	=> $channels
	);
	$player->start;
        $start_time = [gettimeofday];
        $current_sample = 0;
        $silent = 0;
    }

    method stop () {
        $player->stop;
        $silent = 1;
    }

    method update () {
	$silent  and  return;

        my $end_sample  = int (tv_interval($start_time) * $rate + 0.5);
        my $todo        = $end_sample - $current_sample;
        my $collected = $self->fetch_data($todo,$current_sample);
        my $piddle = short($collected) * $amplitude;
	$player->send_piddle($piddle);
        $current_sample += $todo;
    }

    method current_sample {
        return $current_sample;
    }

}

1;

__END__

=head1 NAME

Audio::Aoede::Server - real-time sound

=head1 DESCRIPTION

This module is a helper to add real-time sound to a Perl program.  It
is, despite its name, not a standalone server: It manages the
connection and data flow to a "real" server, implemented as a simple
pipe open to SoX.

=head2 The Back-end: SoX

The actual sound (i.e. feeding your computer's sound card) is
generated by L<SoX|https://en.wikipedia.org/wiki/SoX>.  SoX is
available as a package from Linux distributions, but also available on
Windows.

SoX is also able to store sound generated by the Audio::Aoede modules
in compressed formats like OGG or MP3, which might come in handy
later.  This is not yet implemented.

SoX also has its own synthesizer, mixer and effects library, so it is
a lot of fun to play with.  We don't use these here, though.

=head1 METHODS

=head2 C<new>

The constructor takes key/value pairs as arguments.  All of them are
optional.

=over

=item C<rate>

The number of samples per second.  Defaults to 44100.

=item C<encoding>

How the samples are encoded, in the terminology of SoX.  Defaults to
C<"signed-integer">.  Note that some functions only work with this
encoding, or return sound in this encoding.

=item C<bits>

The number of bits per sample.  Defaults to 16.  Note that some
functions only work with this bit depth, or return sound in this bit
depth.

=item C<channels>

The number of channels.  Defaults to 1.

=back

=head2 C<$sound = $s-E<gt>fetch_data($n_samples,$since)>

Returns a L<PDL> object containing C<$n_samples> samples, to be played
after C<$since>.  If C<$since> is omitted, then it returns the samples
to be played after the previous call to C<fetch_data>.

The PDL object contains floating point numbers.  This makes it robust
against overflow when the sound is modified by effects, but it it
can't be played back directly without being converted appropriately.

=head2 C<$s-E<gt>add_voices(@voices)>

Add the list of voices in C<@voices> to the server.  The voices must
behave like L<Audio::Aoede::Voice> objects.

=head2 C<$s-E<gt>remove_voice($voice)>

Remove C<$voice> from the server.  Does nothing if the voice was not
added before.

=head2 C<$s-E<gt>start>

Start the server.  This creates the SoX instance and starts clocking
time.

=head2 C<$s-E<gt>stop>

Stop the server.  Stop SoX, and set the server to silent.

=head2 C<$s-E<gt>update>

This is the main method to call in a loop when using the server.  The
method does its own time management, but no event management: You just
need to call it regularly without parameters.  I (haj) found it works
good enough with a time tick of 20 ms (or 50 calls per second) which I
organize with a L<Prima::Timer>, which is a timer I use for animations
in my L<Prima> programs anyway.

=head2 C<$s-E<gt>current_sample()

Return the next sample to be processed.  Used by
L<Audio::Aoede::UI::Oscilloscope>.

